# 前端组件的设计原则

## 组件设计的基本原则

一个组件的**复杂度**，主要来源就是自身的状态；即组件自身需要维护多少个不依赖于外部输入的状态。

组件开发中，如何将数据和 UI 解耦，是最重要的工作。

组件开发过程中，时刻谨记、思考是否符合以下的原则，可以帮助你开发一个更完善的通用组件。

### 单一职责 （Single responsibility）

> 当一个组件只有一个改变的原因时，它有一个单一的职责。

编写 React 组件时要考虑的基本准则是单一职责原则。单一职责原则(缩写：`SRP`)要求组件有一个且只有一个变更的原因。

组件的职责可以是呈现列表，或显示日期选择器，或发出 `HTTP` 请求，或绘制图表，或延迟加载图像等。

你的组件应该只选择一个职责并实现它。当你修改组件实现其职责的方式（例如，更改渲染的列表的数量限制），它有一个更改的原因。

为什么只有一个理由可以改变很重要？因为这样组件的修改隔离并且受控。单一职责原则限制了组件的大小，使其集中在一件事情上。集中在一件事情上的组件便于编码、修改、重用和测试。

#### 多重职责陷阱

当一个组件有多个职责时，就会发生一个常见的问题。乍一看，这种做法似乎是无害的，并且工作量较少：

- 你立即开始编码：无需识别职责并相应地规划结构
- 一个大的组件可以做到这一切：不需要为每个职责创建组成部分
- 无拆分-无开销：无需为拆分组件之间的通信创建 `props` 和 `callbacks`

这种幼稚的结构在开始时很容易编码。但是随着应用程序的增加和变得复杂，在以后的修改中会出现困难。

![turn_off](image/turn_off.jpg)

这种设计很脆弱。意外的副作用是很难预测和控制的。

单一职责可以保证组件是最细的粒度，且有利于复用。但太细的粒度有时又会造成组件的碎片化。

(单一职责原则只是美好的理论，实际操作起来效率太低了，一般按照业务功能划分一下，对于重复比较多的功能再抽离出成组件复用，比较高效，不论是对开发效率和维护成本上来说。)

因此单一职责组件要建立在**可复用**的基础上，对于不可复用的单一职责组件，我们仅仅作为独立组件的内部组件即可。

### 封装（Encapsulated）

> 良好的组件封装应该**隐藏内部细节和实现意义**，并通过**props**来控制行为和输出。

> 注意：
>
> **减少访问全局变量**：因为它们打破了封装，创造了不可预测的行为，并且使测试变得困难。可以将全局变量作为组件的 props，而不是直接引用。

耦合是决定组件之间依赖程度的系统特性。根据组件的依赖程度，可区分两种耦合类型：

- 当应用程序组件对其他组件知之甚少或一无所知时，就会发生 **松耦合**。
- 当应用程序组件知道彼此的许多详细信息时，就会发生 **紧耦合**。

#### 松耦合应用(封装组件)

![loose](image/loose.jpg)

#### 紧耦合应用(无封装组件)

![s](image/strict.jpg)

**松耦合**会带来以下好处：

- 可以在不影响应用其它部分的情况下对某一块进行修改。
- 任何组件都可以替换为另一种实现
- 在整个应用程序中实现组件复用，从而避免重复代码
- 独立组件更容易测试，增加了测试覆盖率

相反，紧耦合的系统会失去上面描述的好处。主要缺点是很难修改高度依赖于其他组件的组件。即使是一处修改，也可能导致一系列的依赖组件需要修改。

**封装** 或 **信息隐藏** 是如何设计组件的基本原则，也是松耦合的关键。

### 组合（Composable）

> 一个组合式组件是由更小的特定组件组合而成的。

> 具有多个功能的组件，应该转换为多个小组件。
> 单一责任原则描述了如何将需求拆分为组件，封装描述了如何组织这些组件，组合描述了如何将整个系统粘合在一起。

如乐高积木

![pack](./image/packaging.jpg)

### 通用性（Reusable）

> 可重用的组件，一次编写多次使用。

避免重复造轮子

#### 复用第三方库

#### 应用内的复用

代码重复增加了复杂性和维护工作，但没有增加显著的价值。逻辑更新迫使您修改应用程序中的所有重复代码。

重复问题可以用可复用组件来解决。一次编写，多次使用。

但是，复用并非毫无成本。只有一个组件符合单一责任原则并且具有合理的封装时，它是可复用的。

符合单一职责原则是必须的：

> 复用一个组件实际上就意味着复用其职责

当一个组件错误地有多个职责时，就会增加复用时的开销。

尽量避免代码重复，重复两次及以上的代码，考虑一下是否可以复用？

通用性虽好，但会浪费开发者很多精力，因此在抽象业务组件之前，请问自己：

```
* 存在代码重复吗？如果只使用一次，或者只是某个特定用例，可能嵌入组件中更好。

* 如果它只是几行代码，分隔它反而需要更多的代码，那是否可以直接嵌入组件中？

* 性能会收到影响吗？更改state/props会导致重新渲染，当发生这种情况时，你需要的是 只是重新去渲染经过diff之后得到的相关元素节点。在较大的、关联很紧密的组件中，你可能会发现状态更改会导致在不需要它的许多地方重新呈现，这时应用的性能就可能会开始受到影响。

* 你是否有一个明确的理由？分离代码我想要实现什么？更松散的耦合、可以被复用等，如果回答不了这个问题，那最好先不要从组件中抽离。

* 这些好处是否超过了成本？分离代码需要花费一定的时间和精力，我们要在业务中去衡量，有所取舍。
```

### 纯组件和非纯组件 （Pure or Almost-pure）

> 纯组件总是为相同的属性值渲染相同的元素

在函数编程属于中，对于给定的相同输入，纯函数总是返回相同的输出，并且不会对外界产生副作用

```js
function sum(a, b) {
  return a + b;
}
sum(5, 10); // => 15
```

对于给定的两个数字，sum() 函数总是会返回相同的结果。

当一个函数输入相同，而输出不同时，它就不是一个纯函数。当这个函数依赖于全局的状态时，就不是一个纯函数

```js
let use = false;

function sum(a, b) {
  if (use) {
    return null;
  }
  use = true;
  return a + b;
}
sum(5, 10); // => 15
sum(5, 10); // => null
```

```
非纯组件有显示的副作用，我们要尽量隔离非纯代码。

将全局变量作为props传递给组件，而非将其注入到组件的作用域中。

将网络请求和组件渲染分离，只将数据(props)传递给组件，保证组件职责的单一性，也能将非纯代码从组件中隔离。
```

### 可测试 （Testable and Tested）

> 测试不仅仅是自动检测错误，更是检测组件的逻辑。 如果一个组件测试不易于测试，很大可能是你的组件设计存在问题。

### 富有意义 （Meaningful）

> 开发人员大部分时间都在阅读和理解代码，而不是实际编写代码。 有意义的函数、变量命名，可以让代码具有良好的可读性。

### 最后

我想提醒大家的是：应该更注重以上这些组件设计的原则和你已知的一些最佳实践在实际中的应用。虽然你应该尽力维护良好的设计，但是不要为了包装 组件 或一个取消请求而有损代码完整性，同时总是把理论置于现实世界结果之上的人也往往会让他们的工作受到影响。大型软件项目有许多活动部分，软件工程的许多方面与编码没有特别的关系，但仍然是不可或缺的，例如遵守最后期限和处理非技术期望。

此外，组件规划和设计的概念也适用于组件重构。虽然用了 50 年的时间来计划一切令人难以忍受的细节，然后从一开始就完美地编写它就会很好，回到现实世界，我们往往会遇到这种情况，即为了赶进度而不能使代码达到完美的预期。然而，一旦我们有了空闲时间，那么一个推荐的做法就是回过头来重构早期不够理想的的代码，这样它就可以作为我们向前发展的坚实基础。

## 参考链接

- [可靠 React 组件设计的 7 个准则](https://dmitripavlutin.com/7-architectural-attributes-of-a-reliable-react-component/)
- [前端组件设计原则](https://juejin.im/post/6844903767108747278)
- [Clean Code Blog](https://blog.cleancoder.com/uncle-bob/2014/05/08/SingleReponsibilityPrinciple.html)
- [可靠React组件设计的7个准则之终篇](https://juejin.im/post/6844903919760441352)
